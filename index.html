<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Søk"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS-view-布局详解3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/11/iOS-view-布局详解3/" class="article-date">
  <time datetime="2016-09-11T09:50:13.000Z" itemprop="datePublished">2016-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/11/iOS-view-布局详解3/">iOS view 布局详解3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="AutoLayout-API"><a href="#AutoLayout-API" class="headerlink" title="AutoLayout API"></a>AutoLayout API</h2><p>要想用好autolayout, 知道创建和使用约束是不够的, 还要熟悉和合理使用iOS系统提供的跟autolayout相关的API. </p>
<p><img src="https://cloud.githubusercontent.com/assets/1595401/18416326/bb4f4656-7843-11e6-923d-b9559154c136.png" width="480"></p>
<p>上面的这些方法有些是需要我们重载, 有些是直接调用的, 想要合理正确运用这些方法, 需要理解autolayout的工作原理和布局流程, </p>
<h2 id="布局流程"><a href="#布局流程" class="headerlink" title="布局流程"></a>布局流程</h2><p>在本系列文章的第一篇中, 我们提到了没有引入autolayout之前, view通过直接设置几何属性来布局的布局流程, 在引入autolayout后, 在原有的流程中加入了约束更新</p>
<p><img src="https://cloud.githubusercontent.com/assets/1595401/18416327/bb52a710-7843-11e6-8442-d8a6d27548a5.png" width="480"></p>
<p>从约束被更新到view被显示到屏幕上经历了上图中从左到右3个周期</p>
<ul>
<li>自下而上(先子view再父view)的约束更新周期, 这个周期相关的方法标注为红色</li>
<li>自上而下(先父view再子view)的布局周期, 这个周期相关的方法标注为黄色</li>
<li>自上而下的绘制周期, 这个周期相关的方法标注为蓝色</li>
</ul>
<p><img src="https://cloud.githubusercontent.com/assets/1595401/18416324/bb4e6d76-7843-11e6-8d9c-5d8451c4bf3a.png" width="480"></p>
<p>每个周期可以通过调用对应的方法来触发(Trigger), 系统会在每个周期调用相应的方法, 我们可以重载(Override)这些方法来实现自定义的布局逻辑, 后面会提到使用这些方法的注意事项</p>
<p>跟老的方式一样, 布局流程是一个和系统runloop配合循环往复的过程</p>
<p><img src="https://cloud.githubusercontent.com/assets/1595401/18416323/bb4c994c-7843-11e6-861e-c0b568901e99.png" width="480"></p>
<h3 id="Constraints-Change"><a href="#Constraints-Change" class="headerlink" title="Constraints Change"></a>Constraints Change</h3><p>系统会在每个runloop都去检查布局系统中的约束表达式是否发生了变化, Apple提到一下几点会引起布局约束表达式变化</p>
<ul>
<li>某个约束被Activating或是被Deactivating(iOS8及以后)</li>
<li>改变某个约束的constant或priority</li>
<li>添加或是移除view</li>
</ul>
<p>如果约束表达式发生了变化, autolayout系统会根据新的表达式计算出view新的几何属性(这时并没有根据新的值来布局view),  得到新的几何属性的view将调用其superview的setNeedsLayout方法(这样在接下来的布局周期时系统根据新的几何属性来布局这个view)</p>
<h3 id="Deferred-Layout-Pass"><a href="#Deferred-Layout-Pass" class="headerlink" title="Deferred Layout Pass"></a>Deferred Layout Pass</h3><p>这个阶段包含了下面两个周期</p>
<p><img src="https://cloud.githubusercontent.com/assets/1595401/18416325/bb4eeb52-7843-11e6-80d9-f22d30e888af.png" width="480"></p>
<ul>
<li>Update constraints<br>  之前提到过, 这个周期通过调用-setNeedsUpdateConstraints来触发, 系统会调用-updateConstraints这个方法, 我们可以重载这个方法来做一些更新约束相关的事情, 但在重载时要注意以下几点<ul>
<li>不要在这个方法里面做会让约束失效的事, 比如移除约束或是移除view</li>
<li>不要在这个方法里面调用跟Layout和Display周期相关的方法</li>
<li>一定要在方法的最后调用 [super updateConstraints]</li>
</ul>
</li>
<li>Layout<br>  这个周期通过调用-setNeedsLayout来触发, 系统会调用-layoutSubviews这个方法, 我们可以重载这个方法来直接设置子view几何属性, 建议只在用来完成不能通过约束来实现的布局效果时重载, 注意以下几点<ul>
<li>不要忘记调用[super layoutSubviews]</li>
<li>不要改变任何不在这个view子树里面的view的几何属性</li>
<li>不要调用-setNeedsUpdateConstraints</li>
<li>不要在这里修改布局约束<br>+<br>上面提到的-setNeedsUpdateConstraints和-setNeedsLayout都相当于是设置一个标志位, 然后系统会在后面的某个时候来更新约束或是布局view. 但是有时我们需要立马得到结果, 所以系统还提供了两个方法</li>
</ul>
</li>
<li>-updateConstraintsIfNeeded: 对view调用这个方法会使其立即完成Update constraints这个周期,</li>
<li>-layoutIfNeeded:对view调用这个方法会使其立即完成布局, 可以使用这个方法在autolayout中实现view几何相关的动画效果</li>
</ul>
<h2 id="VC上的跟布局相关的API"><a href="#VC上的跟布局相关的API" class="headerlink" title="VC上的跟布局相关的API"></a>VC上的跟布局相关的API</h2><p>ViewController上有如下跟布局相关的方法</p>
<ul>
<li>-updateViewConstraints  这个方法会在这个VC的根View的约束需要更新时被系统调用, 实际系统是在这个方法的最后调用了根view的-updateConstraints. 我们可以重载这个函数, 在这里可以给根view和其子view添加布局约束, 重载时要注意的是一定要调用[super updateViewConstraints]</li>
<li>-viewWillLayoutSubviews 这个方法会在这个VC的根View的-layoutSubviews被调用的前一刻被系统调用</li>
<li>-viewDidLayoutSubviews 这个方法会在这个VC的根View的-layoutSubviews返回后被系统立即调用, 这时只能保证根view的第一层子view的布局已经完成</li>
</ul>
<h2 id="在哪里建立约束"><a href="#在哪里建立约束" class="headerlink" title="在哪里建立约束?"></a>在哪里建立约束?</h2><p>到底该在哪里建立约束才合适呢? 其实这是一个非常重要的问题, 虽然系统并没有强制要求. 但是不把约束的位置不合适, 很可能会导致得不到期望的布局效果, 也增加了后期维护代码的难度.</p>
<p>下面两个位置是建立约束的极佳选择:</p>
<ul>
<li>VC的viewDidLoad, 在这里可以建立VC根view及其子view间的约束</li>
<li>自定义view的init方法, 可以建立view和其子view的约束<br>那之前提到的-updateViewConstraints/-updateConstraints呢? 建议是这里只更新约束, 不要建立新的约束 –看看这两个方法的名称</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里讨论了autolayout的原理和流程, 介绍了系统提供的API和使用注意事项. 下一篇中会实践一下AutoLayout, 然后介绍经常使用的Masonry这个第三方库</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/11/iOS-view-布局详解3/" data-id="cisyf8lv70000h4vyvdnh4anu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-view-布局详解2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/18/iOS-view-布局详解2/" class="article-date">
  <time datetime="2016-08-18T09:50:13.000Z" itemprop="datePublished">2016-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/18/iOS-view-布局详解2/">iOS view 布局详解2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="新的布局方式"><a href="#新的布局方式" class="headerlink" title="新的布局方式"></a>新的布局方式</h2><p>在布局详解1中我们讨论iOS中通过直接设定View的几何属性的布局方式, 也提到了autoresizingMask特性和其局限性. 现在我们来说说AutoLayout.这是Apple在iOS6开始引入的全新的布局方式.<br>官方文档对AutoLayout的说明:<br>“Auto Layout dynamically calculates the size and position of all the views in your view hierarchy, based on constraints placed on those views. “<br>在AutoLayout中, 我们不再直接设置view的几何属性, 而是通过给View添加约束(constraints), 系统会根据这些约束来计算出view的几何属性并实现布局.</p>
<p><img src="https://cloud.githubusercontent.com/assets/1595401/17772308/b0e47ad2-657a-11e6-8bba-0ba2bbec888d.png" width="340"></p>
<p>上图是Apple在WWDC2015 Session 218 中对autolayout系统的整体描述.系统的Layout Engine根据提供的输入(最左边4个)来实现布局效果, 下面我们来分别说明这几个输入</p>
<h2 id="约束-constraints"><a href="#约束-constraints" class="headerlink" title="约束(constraints)"></a>约束(constraints)</h2><p>在Apple的文档中有提到在autolayout系统中, view的布局是通过一系列的线性等式描述的. 而一个约束就是一个等式. 这其实是autolayout的实现原理, 对于我们来讲, 可以把一个约束理解为描述一个view或是两个view之间的某个布局特性的关系, 说起来太抽象, 看下面的示意图吧</p>
<p><img src="https://cloud.githubusercontent.com/assets/1595401/17772316/b1188138-657a-11e6-83ea-043345f09ac5.png" width="480"></p>
<p>一个约束就是一个这样的等式 item1.attribute1 = multiplier ⨉ item2.attribute2 + constant<br>上图蓝色view和红色view下面的等式就是描述它们之间间距为8的约束等式.<br>在iOS系统中, 约束对应的是NSLayoutConstraint这个类,  来看下头文件中定义(为方便讨论, 我省去了注释和跟VFL相关的方法)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSLayoutConstraint</span> : <span class="title">NSObject</span></span></span><br><span class="line">+(instancetype)constraintWithItem:(<span class="keyword">id</span>)view1 attribute:(<span class="built_in">NSLayoutAttribute</span>)attr1 relatedBy:(<span class="built_in">NSLayoutRelation</span>)relation toItem:(nullable <span class="keyword">id</span>)view2 attribute:(<span class="built_in">NSLayoutAttribute</span>)attr2 multiplier:(<span class="built_in">CGFloat</span>)multiplier constant:(<span class="built_in">CGFloat</span>)c;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">UILayoutPriority</span> priority;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">assign</span>) <span class="keyword">id</span> firstItem;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSLayoutAttribute</span> firstAttribute;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSLayoutRelation</span> relation;</span><br><span class="line"><span class="keyword">@property</span> (nullable, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) <span class="keyword">id</span> secondItem;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSLayoutAttribute</span> secondAttribute;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">CGFloat</span> multiplier;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">CGFloat</span> constant;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>可以看到除了priority(将在后面讨论)外, 之前等式中的每个项都对应NSLayoutConstraint中的一个property. NSLayoutConstraint提供了一个类方法来创建constraint对象.</p>
<ul>
<li>firstItem和secondItem是id类型, 这是因为NSLayoutConstraint不仅用于iOS(UIView), 还用于OS X(NSView), 对于iOS开发来说, firstItem和secondItem的类型是UIView.</li>
<li>firstAttribute和secondAttribute就是之前提到的布局特性, 布局特性都是系统预定义的,有如下几种</li>
<li></li>
<li><ul>
<li>大小特性: Height, Width</li>
</ul>
</li>
<li><ul>
<li>位置特性: Top, Leading, Trailing, Left, Right, Bottom, CenterX, CenterY, Bottom<br><img src="https://cloud.githubusercontent.com/assets/1595401/17772309/b0e45a02-657a-11e6-821e-8021c1fde54f.png" width="340"></li>
</ul>
</li>
<li><p>NSLayoutConstraint中的relation描述了这个约束的等式关系, 除了相等之外还可以是小于等于和大于等</p>
</li>
</ul>
<p><img src="https://cloud.githubusercontent.com/assets/1595401/17772307/b0e42000-657a-11e6-8287-d1f28b91dbd9.png" width="340"></p>
<ul>
<li>multiplier和constant都是CGFloat类型</li>
</ul>
<p>对于一个constraint等式, 要注意以下几点</p>
<ul>
<li>除了constant之外, 其他的property都是readonly的</li>
<li>建立约束等式, 规则如下:<br>大小特性和位置特性之间不能建立约束等式<br>只能给大小特性设置constant值<br>水平位置特性和垂直位置特性之间不能建立约束等式<br>Leading, Trailing和Left, Right之间不能建立约束等式</li>
</ul>
<p>##优先级(priority)<br>NSLayoutConstraint中唯一一个没有出现在约束等式中的property就是优先级(priority), 它的类型是UILayoutPriority</p>
<p><img src="https://cloud.githubusercontent.com/assets/1595401/17772312/b0ea6adc-657a-11e6-8f8c-a2945b627908.png" width="340"></p>
<p>UILayoutPriority等同于float类型(但取值范围是0-1000), 系统预定义了4个不同的优先级. 在autolayout在布局的时候会先满足优先级高的约束, 其次考虑优先级较低的约束. autolayout系统会满足所有优先级是1000的约束,  默认情况下, 通过+ constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:方法创建的约束的优先级都是1000. 对于其他等级的优先级, autolayout会在满足最高优先级约束后尽力满足.<br>NSLayoutConstraint的priority属性虽然没有被标识为readonly, 但是并不是能随意改变, 当一个约束被添加到view后, 以下两种情况会导致exception</p>
<ul>
<li>降低一个原本优先级为1000(UILayoutPriorityRequired)的约束的优先级</li>
<li>将一个原本优先级较1000低的约束的优先级设置为1000<br>所以动态调整约束的优先级并不是很好的实践</li>
</ul>
<h2 id="视图-view"><a href="#视图-view" class="headerlink" title="视图(view)"></a>视图(view)</h2><p>约束描述的是view的布局属性的关系, 但仅仅是把约束创建出来是不够的, 还要把约束添加到合适的view上这个约束才能生效, autolayout要求约束(constraint)被添加到这个约束描述的两个view的公共superview上</p>
<p>例如下图示意中描述两个带高亮view的约束需要被添加到黄色箭头指定的view上</p>
<p><img src="https://cloud.githubusercontent.com/assets/1595401/17772310/b0e75d4c-657a-11e6-8718-7863f64403bf.png" height="100"><br><img src="https://cloud.githubusercontent.com/assets/1595401/17772311/b0e7cba6-657a-11e6-88f4-bfdb9dbca4c5.png" height="100"><br><img src="https://cloud.githubusercontent.com/assets/1595401/17772313/b1131680-657a-11e6-975e-7a18911b9ff3.png" height="100"></p>
<h3 id="添加和移除约束方法"><a href="#添加和移除约束方法" class="headerlink" title="添加和移除约束方法"></a>添加和移除约束方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//添加约束使用的是UIView的两个方法</span></span><br><span class="line">- (<span class="keyword">void</span>)addConstraint:(<span class="built_in">NSLayoutConstraint</span> *)constraint</span><br><span class="line">- (<span class="keyword">void</span>)addConstraints:(<span class="built_in">NSArray</span>&lt;__kindof <span class="built_in">NSLayoutConstraint</span> *&gt; *)constraints</span><br><span class="line"> <span class="comment">//约束也可以被从view上移除, 被移除的约束将不再参与autolayout布局</span></span><br><span class="line">- (<span class="keyword">void</span>)removeConstraint:(<span class="built_in">NSLayoutConstraint</span> *)constraint</span><br><span class="line">- (<span class="keyword">void</span>)removeConstraints:(<span class="built_in">NSArray</span>&lt;__kindof <span class="built_in">NSLayoutConstraint</span> *&gt; *)constraints</span><br></pre></td></tr></table></figure>
<p>要注意的是如果将一个view从视图层级上移除(比如调用了removeFromSuperView), 会对之前添加的约束产生什么影响</p>
<p><img src="https://cloud.githubusercontent.com/assets/1595401/17772314/b1138f5c-657a-11e6-89a8-7a46f50f74c3.png" width="200"></p>
<p>例如在上图中:</p>
<ul>
<li>view1和view2之间有约束A被添加到view1上</li>
<li>view3和view4之间有约束B被添加到view2上</li>
<li>view3和view5之间有约束C被添加到view1上</li>
</ul>
<p>当对view2发送removeFromSuperView后, 约束A和C会被系统清理掉(约束被从view1上移除, 跟其他对象一样, 如果没到到这个约束对象的强引用, 这个约束对象会被释放), 约束B不受影响, 但是如果约束B是被添加到view1上的话, 对view2发送removeFromSuperView也会导致约束B被清除.</p>
<p>总结出就是当一个view被从视图层级上移除时, 被添加到这个view子树之外的view上的 ,描述跟被移除view子树相关的约束会被系统清除.</p>
<h2 id="Intrinsic-Content-Size"><a href="#Intrinsic-Content-Size" class="headerlink" title="Intrinsic Content Size"></a>Intrinsic Content Size</h2><p>autolayout系统接收的另一个输入是view的intrinsic Content Size, 它是UIView方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGSize</span>)intrinsicContentSize</span><br></pre></td></tr></table></figure></p>
<p>返回的结果, Apple文档中对其描述是<br>A size indicating the natural size for the receiving view based on its intrinsic properties.</p>
<p>可以将其理解为view提供给autolayout系统的显示view自身需要的大小.<br>大小分为宽和高两个维度, 系统中一些UI控件会根据其内容来提供其中的一个或两个值</p>
<p><img src="https://cloud.githubusercontent.com/assets/1595401/17772315/b1153280-657a-11e6-80e9-5c1fa355ec81.png" width="340"></p>
<p>如果某个维度没有值提供, 对应的返回值是UIViewNoIntrinsicMetric<br>跟intrinsic Content Size相关的两个概念是Compression-Resistance和Content-Hugging, 其实intrinsicContentSize可以被描述为Compression-Resistance和Content-Hugging两组约束等式:</p>
<p><img src="https://cloud.githubusercontent.com/assets/1595401/17772317/b118b27a-657a-11e6-9cc5-3e692d8952bd.png" width="340"></p>
<p>我们一般提及Compression-Resistance和Content-Hugging的时候说的就是这两组约束等式的优先级, Compression-Resistance的默认优先级是750, 而Content-Hugging的默认优先级是250.<br>系统提供了下面的方法来获取和设置相应的优先级</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UILayoutPriority</span>)contentCompressionResistancePriorityForAxis:(<span class="built_in">UILayoutConstraintAxis</span>)axis</span><br><span class="line">- (<span class="keyword">void</span>)setContentCompressionResistancePriority:(<span class="built_in">UILayoutPriority</span>)priority forAxis:(<span class="built_in">UILayoutConstraintAxis</span>)axis</span><br><span class="line">- (<span class="built_in">UILayoutPriority</span>)contentHuggingPriorityForAxis:(<span class="built_in">UILayoutConstraintAxis</span>)axis</span><br><span class="line">- (<span class="keyword">void</span>)setContentHuggingPriority:(<span class="built_in">UILayoutPriority</span>)priority forAxis:(<span class="built_in">UILayoutConstraintAxis</span>)axis</span><br></pre></td></tr></table></figure>
<p>intrinsicContentSize是一个很有用的特性, 后面我们再讨论如何利用这个特性来帮助我们更好的使用autolayout</p>
<h2 id="使用AutoLayout时遇到问题"><a href="#使用AutoLayout时遇到问题" class="headerlink" title="使用AutoLayout时遇到问题"></a>使用AutoLayout时遇到问题</h2><p>使用autolayout来布局可能会遇到以下几种错误导致布局问题</p>
<ul>
<li>Ambiguous Layouts, 我们提供的约束不充分, 如果用autolayout来实现布局的话, 每个view的横向和纵向都需要两个约束(intrinsicContentSize可以认为是约束), 要是我们提供的约束不充分的话, 系统在根据约束布局时view的某个几何特性得不到确定的解, 也就是所说的二义性, 这是系统会使用一个不确定的值来填充. UIView的- (BOOL)hasAmbiguousLayout方法可以在运行时来验证某个view是否存在Ambiguous Layouts</li>
<li>Unsatisfiable Layouts, 我们的提供的约束不能同时被满足, 比如一个约束说view的宽是10, 另一个约束说宽是8, 两个的优先级又相同的情况下, 就会出现这种情况. 系统会在console里面打印说这两个约束出现了冲突(conflict). 由于系统不能同时满足这两个约束, 所以系统会选取一条约束来break, 就是说不满足这一条了, 这样来给出一个结果. 但至于选取哪一条是不确定的. Unsatisfiable Layouts是比较严重的问题, 不仅我们得不到想要的布局效果,在老的iOS版本还可能会引起APP的crash. 所以遇到这个错误一定要分析解决掉</li>
<li>Logical Errors. 就是我们的提供的约束等式有逻辑上的错误导致系统的布局结果不是我们期望的那样</li>
</ul>
<p>这篇文章中我们对autolayout大致有了清楚的认识, 下篇文章会对autolayout的原理进行深入的讨论, 然后介绍如何使用系统提供的跟autolayout相关的API</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/18/iOS-view-布局详解2/" data-id="cis0aiw3v0000sxvy9c18j0n2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-view-布局详解1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/26/iOS-view-布局详解1/" class="article-date">
  <time datetime="2016-07-26T09:50:13.000Z" itemprop="datePublished">2016-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/26/iOS-view-布局详解1/">iOS view 布局详解1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="UIKit坐标系统"><a href="#UIKit坐标系统" class="headerlink" title="UIKit坐标系统"></a>UIKit坐标系统</h2><p>对于一个平面坐标系统, 要清楚它的原点(origin)和延伸方向, iOS中UIKit层和CALayer层的坐标系统是不一样的,<br><img src="https://cloud.githubusercontent.com/assets/1595401/17134128/836ef4c8-535b-11e6-84ca-75f7ae6c08ba.png" width="340"></p>
<p>针对view布局时只需要考虑UIKit的坐标系统就可以了</p>
<h2 id="UIView的几何属性"><a href="#UIView的几何属性" class="headerlink" title="UIView的几何属性"></a>UIView的几何属性</h2><p>我们只考虑view的3个重要的几何属性:</p>
<ul>
<li>frame 描述的是view在其superview坐标系中的位置和大小(可以理解为在superview圈住view全部内容的最小矩形)</li>
<li>bounds 描述的是view在其自身坐标系中的位置和大小</li>
<li>center 是view在其superview坐标系中的中心点</li>
</ul>
<p><img src="https://cloud.githubusercontent.com/assets/1595401/17134436/f26a33fa-535c-11e6-80d1-a7346d4d9b53.png" width="220"><br><img src="https://cloud.githubusercontent.com/assets/1595401/17134434/f23f2412-535c-11e6-8486-5a72572e37cb.png" width="230"><br><img src="https://cloud.githubusercontent.com/assets/1595401/17134435/f24257e0-535c-11e6-80f4-d8033a4c5db9.png" width="200"></p>
<p>从上图我们可以看出这3个属性的值的区别<br>要注意的是,这3个属性值不是相互独立的, 当设置其中一个时可能会影响另一个</p>
<ul>
<li>当设置frame属性时, bounds的size会自动调整去匹配新的frame矩形, center也会自动调整为新的frame矩形的中心点</li>
<li>当设置center属性时, frame的origin会被相应调整</li>
<li>当设置bounds的size时, frame的size会被自动调整来匹配bounds矩形新的size<br>view还有一个几何属性是transform, 可以通过改变transform来实现view的旋转和拉伸, 这里我们不考虑它</li>
</ul>
<h2 id="iOS中布局view的3种方式"><a href="#iOS中布局view的3种方式" class="headerlink" title="iOS中布局view的3种方式:"></a>iOS中布局view的3种方式:</h2><ol>
<li>直接设置view的几何属性, 最为常见的就是直接设置frame</li>
<li>在1的基础上为view设置autoresizingMask, 用于描述一个view的superview的大小发生改变时，这个view的布局改如何调整</li>
<li>Auto Layout, 通过一系列的约束(constraints)来描述view间的布局关系, 系统会通过这些constraints来计算出view的几何属性</li>
</ol>
<h3 id="直接设置view的几何属性"><a href="#直接设置view的几何属性" class="headerlink" title="直接设置view的几何属性"></a>直接设置view的几何属性</h3><p>这种方式是最直观的, 通过直接对view几何属性值的设定到达期望的布局效果.下图是系统在这种方式下的布局过程</p>
<p><img src="https://cloud.githubusercontent.com/assets/1595401/17267810/1720d5aa-5646-11e6-8e3a-bc05192e082c.png" width="600"></p>
<p>系统是通过view的layoutSubviews方法来实现布局的, 在一个runloop中, 通过在一个view上直接调用setNeedsLayout,或是改变其几何属性(这时setNeedsLayout会被系统自动调用), view被标记为needsLayout, 在这个runloop的后面, 系统会通过layoutSubviews来重新布局, 这种方式下要注意:</p>
<p><img src="https://cloud.githubusercontent.com/assets/1595401/17267811/1722100a-5646-11e6-87fc-0b1f33d253e1.png" width="600"></p>
<h3 id="AutoresizingMask"><a href="#AutoresizingMask" class="headerlink" title="AutoresizingMask"></a>AutoresizingMask</h3><p>通过直接设置View几何属性来实现布局的最大缺点就是不能自动适配布局的变化, 比如在我们的工程中有很多情况是一个View的大小由网络回传的数据来决定, 这样一来, 在接收到网络数据时, 我们不仅要设置这个View的大小, 还要调整一个页面内其他的View的布局, 还要重新布局其subviews. 在引入Autolayout之前, AutoresizingMask是唯一可以用来实现自适应布局变化的特性, autoresizingMask是UIView的一个属性, 它是一个枚举类型值, 可以被设置为UIViewAutoresizing类型的一个或多个值的组合</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">UIViewAutoresizing</span> autoresizingMask</span><br><span class="line">  </span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">   <span class="built_in">UIViewAutoresizingNone</span>                 = <span class="number">0</span>,</span><br><span class="line">   <span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span>   = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">   <span class="built_in">UIViewAutoresizingFlexibleWidth</span>        = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">   <span class="built_in">UIViewAutoresizingFlexibleRightMargin</span>  = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">   <span class="built_in">UIViewAutoresizingFlexibleTopMargin</span>    = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">   <span class="built_in">UIViewAutoresizingFlexibleHeight</span>       = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">   <span class="built_in">UIViewAutoresizingFlexibleBottomMargin</span> = <span class="number">1</span> &lt;&lt; <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSUInteger</span> <span class="built_in">UIViewAutoresizing</span>;</span><br></pre></td></tr></table></figure>
<p>通过为view设定autoresizingMask来描述当其superview的大小发生改变时，这个view的布局该如何调整, 当其superview的大小变化时, 系统会根据autoresizingMask的值来自动调整view的布局</p>
<p><img src="https://cloud.githubusercontent.com/assets/1595401/17267809/171f5068-5646-11e6-9f84-789763640ea0.png" width="600"></p>
<p>这些值分别代表了</p>
<ul>
<li>UIViewAutoresizingNone view的frame不会随superview的改变而改变</li>
<li>UIViewAutoresizingFlexibleLeftMargin 自动调整view与superview左边的距离保证右边距离不变</li>
<li>UIViewAutoresizingFlexibleWidth 自动调整view的宽，保证与superView的左右边距不变</li>
<li>UIViewAutoresizingFlexibleRightMargin 自动调整view与superview右边的距离保证左边距不变</li>
<li>UIViewAutoresizingFlexibleTopMargin 自动调整view与superview顶部的距离保证底部距离不变</li>
<li>UIViewAutoresizingFlexibleHeight 自动调整view的高，保证与superView的顶部和底部距离不变</li>
<li>UIViewAutoresizingFlexibleBottomMargin 自动调整view与superview底部部的距离保证顶部距离不变<br>更多的情况这些值会被组合使用, 比如想要一个view的大小跟随其superView的大小变化而四边的边距不变, 这时我们需要将view的autoresizingMask设置为UIViewAutoresizingFlexibleWidth|UIViewAutoresizingFlexibleHeight. </li>
</ul>
<p>虽然autoresizingMask可以某种意义上说是实现了自动布局调整, 但其能力很有限; 最大的限制是autoresizingMask描述的变化特征只能限于view和其superview, 如果view之间没有直接的父子关系, autoresizingMask就无能为力了.<br>在2012年, Apple在iOS6 SDK中引入了新的布局机制(Auto Layout), 由于其内容较多, 所以放到下一篇来详细介绍.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/26/iOS-view-布局详解1/" data-id="cir8ktabe0005yrs6sha78si7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/10/hello-world/" class="article-date">
  <time datetime="2016-06-10T09:25:30.000Z" itemprop="datePublished">2016-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/10/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/10/hello-world/" data-id="cir8ktabc0004yrs6bvfxxzby" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Swift-Standard-Library-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/30/Swift-Standard-Library-1/" class="article-date">
  <time datetime="2016-01-30T12:02:57.000Z" itemprop="datePublished">2016-01-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/swift/">swift</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/30/Swift-Standard-Library-1/">Swift Standard Library 1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Swift-Standard-Library-1"><a href="#Swift-Standard-Library-1" class="headerlink" title="Swift Standard Library 1"></a>Swift Standard Library 1</h1><p><strong>语法基础和标准库中的协议</strong></p>
<p>学习一门新的语言, 对其标准库的学习是非常重要的, 对标准库中的组件的熟悉程度差不多决定了使用这门语言编程的效率. 这门语言的设计思想和编程风格也在标准库中体现出来. 对于swift来说也不例外, 标准库中提供了很多基础组件, 都需要我们去学习掌握. 那么问题来了, 面多这个庞大的库, 该怎么入手呢?<br>我的方法是: 分类. 把组件的共同点抽象出来, 这样就能快速的建立知识索引, 学习起来就轻松多了.</p>
<p>作为对标准库学习的一个总结, 我分上下两篇来对swift标准库做一个概述. 重点是分类介绍标准库中组件, 这里没有对组件实现的分析. 前不久swift已经开源了其源码, 想要知道标准库中的组件是如何实现的, 还可以去源码一探究竟. </p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>学习标准库的唯一前提是要熟悉语法基础, swift的基础语法可参考这里 <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#" target="_blank" rel="external">The Swift Programming Language</a>, 英文不过关的看这里<a href="http://wiki.jikexueyuan.com/project/swift/" target="_blank" rel="external">The Swift Programming Language 中文版</a>.</p>
<p>在进入标准库之前,这里我们来对swift语法的几个要点加深下理解</p>
<h3 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h3><p>swift中的protocol可以总结为一下几点:</p>
<ul>
<li>类似于其他语言中的接口(interface)</li>
<li>可以被当做类型(type)来使用?</li>
<li>可以通过extension来提供默认实现</li>
</ul>
<p>举例: AnyObject就是一个协议</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">AnyObject</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h3><p>泛型(Generic)是swift中一个重要的特性, 有了Generic, 类型也可以被参数化</p>
<ul>
<li>泛型函数</li>
</ul>
<p>标准库中的swap函数就是一个泛型函数, &lt;&gt;中的T就是泛型参数</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Exchange the values of `a` and `b`.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">swap</span>&lt;T&gt;<span class="params">(<span class="keyword">inout</span> a: T, <span class="keyword">inout</span> <span class="number">_</span> b: T)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>泛型类型</li>
</ul>
<p>Array就是一个泛型类型, 泛型参数是Element</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Array</span>&lt;<span class="title">Element</span>&gt; : <span class="title">CollectionType</span>, <span class="title">MutableCollectionType</span>, <span class="title">_DestructorSafeContainer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Always zero, which is the index of the first element when non-empty.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> startIndex: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">/// A "past-the-end" element index; the successor of the last valid</span></span><br><span class="line">    <span class="comment">/// subscript argument.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> endIndex: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">subscript</span> (index: <span class="type">Int</span>) -&gt; <span class="type">Element</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">subscript</span> (subRange: <span class="type">Range</span>&lt;<span class="type">Int</span>&gt;) -&gt; <span class="type">ArraySlice</span>&lt;<span class="type">Element</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>泛型参数可以有类型约束</li>
</ul>
<p>Dictionary中Key是泛型参数, 但是必须是confirim Hasable这个协议</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dictionary</span>&lt;<span class="title">Key</span> : <span class="title">Hashable</span>, <span class="title">Value</span>&gt; : <span class="title">CollectionType</span>, <span class="title">DictionaryLiteralConvertible</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价的写法是, 类型约束写在where子句中</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dictionary</span>&lt;<span class="title">Key</span>, <span class="title">Value</span> <span class="title">where</span> <span class="title">Key</span>: <span class="title">Hashable</span>&gt; : <span class="title">CollectionType</span>, <span class="title">DictionaryLiteralConvertible</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Typealias"><a href="#Typealias" class="headerlink" title="Typealias"></a>Typealias</h3><p>类型别名, 类似typedef<br>Any就是一个typealias</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// The protocol to which all types implicitly conform.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Any</span> = <span class="class"><span class="keyword">protocol</span>&lt;&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Protocol遇上Generic"><a href="#Protocol遇上Generic" class="headerlink" title="Protocol遇上Generic"></a>Protocol遇上Generic</h3><p>泛型协议? swift中的protocol是不能带有泛型参数的</p>
<p><img src="https://cloud.githubusercontent.com/assets/1595401/12699719/d8e2706a-c800-11e5-94e4-f0b7253eb3d5.png" alt="image"><br>上面的error说protocol不能有泛型参数, 请使用associated type(关联类型), 这个是什么东西? 其实就是这样</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Food</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">feed</span><span class="params">(food: Food)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Kinds of Food</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Grass</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Worm</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cow</span>: <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">//typealias Food = Grass</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">feed</span><span class="params">(food: Grass)</span></span> &#123; <span class="built_in">print</span>(<span class="string">"moo"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bird</span>: <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Food</span> = <span class="type">Worm</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">feed</span><span class="params">(food: Worm)</span></span> &#123; <span class="built_in">print</span>(<span class="string">"chirp"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cow: <span class="type">Cow</span> = <span class="type">Cow</span>()</span><br><span class="line"><span class="comment">//var cow: Animal = Cow()</span></span><br></pre></td></tr></table></figure>
<p>这里Animal这个protocol中的Food就是一个关联类型, 这里要注意一点就是如果我把上次代码中最后一行的注释去掉会有问题吗? 协议不是可以当做类型来使用吗? 然而这里并不行<br><img src="https://cloud.githubusercontent.com/assets/1595401/12699723/fa2b2fb4-c800-11e5-8bdf-b3d84691c7b2.png" alt="image"></p>
<p>error提示说的是凡是带有关联类型的协议只能被当做类型约束使用, 不能当做类型. 这也是为什么在之前提到协议可以当做类型使用时我加上了问号. 至于具体怎么当做类型约束使用, 这里就不再深入了. 接下来我们就正式开始标准库中组件的学习</p>
<h2 id="Protocols"><a href="#Protocols" class="headerlink" title="Protocols"></a>Protocols</h2><p>Apple把swift称为是protocol-oriented的语言, 可想而知protocol在swift中有多重要了, 标准库中现在有89个protocol, 其中带下划线开始的有36个, Apple建议的不要直接使用带下划线的协议, 所以我们重点放在不带下划线的那些上. 为了概述的完整性, 在分类时有些重要的带下划线的protocol也会被提及.</p>
<p>对协议的学习, 我们要关注下这个协议都申明了哪些方法, 如果要confirm这个协议的话, 这个方法都必须要提供实现. 还有这个协议还继承自哪些协议或是申明了哪些关联类型</p>
<blockquote>
<p>为了便于排版, 在这部分的表格中, 函数和操作符只写了名称(构造方法会带外部参数名称), 具体类型签名等可参考<a href="https://developer.apple.com/library/ios/documentation/General/Reference/SwiftStandardLibraryReference/index.html#" target="_blank" rel="external">Swift Standard Library Reference</a></p>
</blockquote>
<h3 id="1-Basic"><a href="#1-Basic" class="headerlink" title="1.Basic"></a>1.Basic</h3><table>
<thead>
<tr>
<th>Protocol Name</th>
<th>Methods</th>
<th>Inherited</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><em>Equtable</em></strong></td>
<td><code>==</code></td>
</tr>
<tr>
<td><strong><em>Comparable</em></strong></td>
<td><code>&lt;</code></td>
<td>Equatable</td>
</tr>
<tr>
<td><strong><em>Hashable</em></strong></td>
<td><code>hashValue</code></td>
<td>Equatable</td>
</tr>
</tbody>
</table>
<p>凡是需要验证对象相等性的类型都应该遵从Equtable.<br><br>凡是需要具备比较操作的都应遵从Comparable, 类型只要在遵从Equtable的基础上提供”&lt;”(小于)方法的实现, 标准库通过这两个操作来得出”&gt;” “&gt;=” “&lt;=”的实现.<br><br>凡是需要被当做Set的元素或是作为Dictionary的Key的类型都应遵从Hasable</p>
<h3 id="2-LiteralConvertible"><a href="#2-LiteralConvertible" class="headerlink" title="2.LiteralConvertible"></a>2.LiteralConvertible</h3><table>
<thead>
<tr>
<th>Protocol Name</th>
<th>Methods</th>
<th>Associated Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><em>BooleanLiteralConvertible</em></strong></td>
<td><code>init(booleanLiteral)</code></td>
<td>BooleanLiteralType</td>
</tr>
<tr>
<td><strong><em>IntegerLiteralConvertible</em></strong></td>
<td><code>init(integerLiteral)</code></td>
<td>IntegerLiteralType</td>
</tr>
<tr>
<td><strong><em>FloatLiteralConvertible</em></strong></td>
<td><code>init(floatLiteral)</code></td>
<td>FloatLiteralType</td>
</tr>
<tr>
<td><strong><em>NilLiteralConvertible</em></strong></td>
<td><code>init(nilLiteral)</code></td>
<td></td>
</tr>
<tr>
<td><strong><em>StringLiteralConvertible</em></strong></td>
<td><code>init(stringLiteral)</code></td>
<td>StringLiteralType</td>
</tr>
<tr>
<td><strong><em>ArrayLiteralConvertible</em></strong></td>
<td><code>init(arrayLiteral)</code></td>
<td>Element</td>
</tr>
<tr>
<td><strong><em>DictionaryLiteralConvertible</em></strong></td>
<td><code>init(dictionaryLiteral)</code></td>
<td>Key, Value</td>
</tr>
<tr>
<td><strong><em>UnicodeScalarLiteralConvertible</em></strong></td>
<td><code>init(unicodeScalarLiteral)</code></td>
<td>UnicodeScalarLiteralType</td>
</tr>
<tr>
<td><strong><em>ExtendedGraphemeClusterLiteralConvertible</em></strong></td>
<td><code>init(extendedGraphemeClusterLiteral)</code></td>
<td>ExtendedGraphemeClusterLiteralType</td>
</tr>
</tbody>
</table>
<p>这些协议可以理解为可以通过这个类型可以通过XX类型转换而来, 来个例子吧</p>
<p><img src="https://cloud.githubusercontent.com/assets/1595401/12699726/18640a0a-c801-11e5-9963-134b320fd429.png" alt="image"><br>上面代码中有一个Circle类型, 即便它有一个接受Float的构造方法, 但是也不能给一个Circle的对象直接赋值Float类型. 如果想要这样的转换,就需要让Circle遵从FloatLiteralConvertible, 就像下面这样</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Float</span></span><br><span class="line">    <span class="keyword">init</span> (radius: <span class="type">Float</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.radius = radius</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">area</span> <span class="params">()</span></span> -&gt; <span class="type">Float</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Circle</span>: <span class="title">FloatLiteralConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(floatLiteral value: <span class="type">Float</span>) &#123;</span><br><span class="line">        radius = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myCircle: <span class="type">Circle</span> = <span class="number">5.0</span></span><br><span class="line"><span class="built_in">print</span>(myCircle.area())</span><br></pre></td></tr></table></figure>
<h3 id="3-Index-Related"><a href="#3-Index-Related" class="headerlink" title="3.Index Related"></a>3.Index Related</h3><table>
<thead>
<tr>
<th>Protocol Name</th>
<th>Methods</th>
<th>Inherited</th>
<th>Associated Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><em>_Incrementable</em></strong></td>
<td><code>successor()</code><br></td>
<td>Equatable</td>
<td></td>
</tr>
<tr>
<td><strong><em>_RandomAccessAmbiguity</em></strong></td>
<td><code>advancedBy</code><br></td>
<td></td>
<td><code>Distance</code></td>
</tr>
<tr>
<td><strong><em>ForwardIndexType</em></strong></td>
<td><code>advancedBy</code><br><code>advancedBy</code><br><code>distanceTo</code><br></td>
<td>_Incrementable</td>
<td><code>Distance</code></td>
</tr>
<tr>
<td><strong><em>BidirectionalIndexType</em></strong></td>
<td><code>predecessor</code><br><code>advancedBy</code><br><code>advancedBy</code><br></td>
<td>ForwardIndexType</td>
<td></td>
</tr>
<tr>
<td><strong><em>ReverseIndexType</em></strong></td>
<td><code>init(_)</code><br><code>base</code><br></td>
<td>BidirectionalIndexType</td>
<td><code>Base</code>, <code>Distance</code></td>
</tr>
<tr>
<td><strong><em>_Strideable</em></strong></td>
<td><code>distanceTo</code><br><code>advancedBy</code><br></td>
<td>Comparable, _Strideable</td>
<td><code>Stride</code></td>
</tr>
<tr>
<td><strong><em>Strideable</em></strong></td>
<td><code>distanceTo</code><br><code>advancedBy</code><br></td>
<td>Comparable, _Strideable</td>
<td><code>Stride</code></td>
</tr>
<tr>
<td><strong><em>RandomAccessIndexType</em></strong></td>
<td><code>distanceTo</code><br><code>advancedBy</code><br></td>
<td>BidirectionalIndexType, Strideable, _RandomAccessAmbiguity</td>
<td></td>
</tr>
<tr>
<td><strong><em>Indexable</em></strong></td>
<td><code>startIndex</code><br><code>endIndex</code><br><code>subscript(position)</code><br></td>
<td></td>
<td><code>Index</code></td>
</tr>
<tr>
<td><strong><em>MutableIndexable</em></strong></td>
<td><code>startIndex</code><br><code>endIndex</code><br><code>subscript(position)</code><br></td>
<td></td>
<td><code>Index</code></td>
</tr>
</tbody>
</table>
<p>Index这一类的protocol除最后两个外的共同点都申明了位置前后移动的方法, 比如ForwardIndexType可以向前移动, 还可以计算两个ForwardIndexType对象之间的位置, 这些protocol一般是被collection的index类型遵从. 而Indexable和MutableIndexable说明的是遵从的类型是可以通过Index来访问其元素. 下篇文章中提到Collection和Index类型时会说明</p>
<h3 id="4-Arithmetic"><a href="#4-Arithmetic" class="headerlink" title="4.Arithmetic"></a>4.Arithmetic</h3><table>
<thead>
<tr>
<th>Protocol Name</th>
<th>Methods</th>
<th>Inherited </th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><em>BitwiseOperationsType</em></strong></td>
<td><code>&amp;</code>, <code>⎟</code>, <code>^</code>, <code>prefix ~</code><br></td>
</tr>
<tr>
<td><strong><em>IntegerArithmeticType</em></strong></td>
<td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>toIntMax</code><br></td>
<td><code>_IntegerArithmeticType</code><br><code>Comparable</code><br></td>
</tr>
<tr>
<td><strong><em>_IntegerType</em></strong></td>
<td></td>
<td><code>IntegerLiteralConvertible</code><br><code>CustomStringConvertible</code><br><code>Hashable</code><br><code>IntegerArithmeticType</code><br><code>BitwiseOperationsType</code><br><code>_Incrementable</code><br></td>
</tr>
<tr>
<td><strong><em>IntegerType</em></strong></td>
<td></td>
<td><code>_IntegerType</code><br><code>RandomAccessIndexType</code><br></td>
</tr>
<tr>
<td><strong><em>SignedNumberType</em></strong></td>
<td><code>prefix -</code>, <code>-</code><br></td>
<td><code>Comparable</code><br><code>IntegerLiteralConvertible</code><br></td>
</tr>
<tr>
<td><strong><em>SignedIntegerType</em></strong></td>
<td><code>init(_)</code><br><code>toIntMax</code><br></td>
<td><code>_SignedIntegerType</code>, <code>IntegerType</code><br></td>
</tr>
<tr>
<td><strong><em>UnsignedIntegerType</em></strong></td>
<td><code>init(_)</code><br><code>toIntMax</code><br></td>
<td><code>_DisallowMixedSignArithmetic</code><br><code>IntegerType</code><br></td>
</tr>
</tbody>
</table>
<p>这类算术protocol申明的都是算术运算相关的方法</p>
<h3 id="5-Sequence-and-Collection"><a href="#5-Sequence-and-Collection" class="headerlink" title="5.Sequence and Collection"></a>5.Sequence and Collection</h3><table>
<thead>
<tr>
<th>Protocol Name</th>
<th>Methods</th>
<th>Inherited</th>
<th>Associated Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><em>GeneratorType</em></strong></td>
<td><code>next</code><br></td>
<td></td>
<td>Element</td>
</tr>
<tr>
<td><strong><em>SequenceType</em></strong></td>
<td><code>generate</code><br><code>map&lt;T&gt;</code><br><code>reduce&lt;T&gt;</code><br><code>filter</code><br><code>contains</code><br><code>flatMap&lt;T&gt;</code><br><code>...</code><br></td>
<td></td>
<td>Generator, SubSequence</td>
</tr>
<tr>
<td><strong><em>CollectionType</em></strong></td>
<td><code>subscript(position)</code><br><code>isEmpty</code><br><code>lazy</code><br><code>startIndex</code><br><code>endIndex</code><br><code>flatten</code><br><code>...</code><br></td>
<td>Indexable, SequenceType</td>
<td>Generator, SubSequence</td>
</tr>
<tr>
<td><strong><em>AnyCollectionType</em></strong></td>
<td></td>
<td>CollectionType</td>
<td></td>
</tr>
<tr>
<td><strong><em>RangeReplaceableCollectionType</em></strong></td>
<td><code>replaceRange</code><br><code>appendContentsOf</code><br><code>insertContentsOf</code><br><code>removeRange</code><br><code>...</code><br></td>
<td>CollectionType</td>
<td>Element</td>
</tr>
<tr>
<td><strong><em>MutableCollectionType</em></strong></td>
<td><code>partition</code><br><code>sortInPlace</code><br><code>...</code><br></td>
<td>MutableIndexable, CollectionType</td>
<td>SubSequence</td>
</tr>
<tr>
<td><strong><em>LazySequenceType</em></strong></td>
<td><code>elements</code><br><code>array</code><br><code>flatMap&lt;Intermediate&gt;</code><br><code>map&lt;U&gt;</code><br><code>flatten</code><br><code>...</code><br></td>
<td>SequenceType</td>
<td>Elements</td>
</tr>
<tr>
<td><strong><em>LazyCollectionType</em></strong></td>
<td><code>flatMap&lt;Intermediate&gt;</code><br><code>map&lt;U&gt;</code><br><code>flatten</code><br><code>...</code><br></td>
<td>CollectionType, LazySequenceType</td>
<td>Elements</td>
</tr>
</tbody>
</table>
<p>GeneratorType封装了迭代一个sequence的接口, 其关联类型Element就是对应sequence的元素类型, 唯一申明的方法next就是返回下一个GeneratorType对象<br><br>SequenceType的generate方法返回就是对应的GeneratorType对象, 所有的SequenceType都可以通过for…in来遍历元素<br><br>CollectionType继承SequenceType, 并且其元素还可以通过Index来索引<br><br>带Lazy名字的sequence和collection其元素会在被访问的时候才求值</p>
<h3 id="6-Misc-其他"><a href="#6-Misc-其他" class="headerlink" title="6.Misc(其他)"></a>6.Misc(其他)</h3><table>
<thead>
<tr>
<th>Protocol Name</th>
<th>Methods</th>
<th>Inherited</th>
<th>Associated Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><em>ErrorType</em></strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong><em>IntervalType</em></strong></td>
<td><code>isEmpty</code><br><code>start</code><br><code>end</code><br><code>contains</code><br><code>...</code><br></td>
<td></td>
<td>Bound</td>
</tr>
<tr>
<td><strong><em>RawRepresentable</em></strong></td>
<td><code>init?()</code><br><code>rawValue</code><br></td>
<td></td>
<td>RawValue</td>
</tr>
<tr>
<td><strong><em>SetAlgebraType</em></strong></td>
<td><code>union</code><br><code>intersect</code><br><code>exclusiveOr</code><br><code>...</code><br></td>
<td>Equatable, ArrayLiteralConvertible</td>
<td>Element</td>
</tr>
<tr>
<td><strong><em>OptionSetType</em></strong></td>
<td><code>union</code><br><code>intersect</code><br><code>exclusiveOr</code><br><code>...</code><br></td>
<td>SetAlgebraType, RawRepresentable</td>
<td>Element</td>
</tr>
<tr>
<td><strong><em>CustomStringConvertible</em></strong></td>
<td><code>description</code><br></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong><em>CustomDebugStringConvertible</em></strong></td>
<td><code>debugDescription</code><br></td>
<td></td>
</tr>
</tbody>
</table>
<p>我把剩下不好分类的protocol放到一起<br><br>Swift2引入了新的错误处理机制, throw语句中的表达必须遵从ErrorType协议<br><br>IntervalType类型是区间类型, 比如[1…4]就是一种区间类型<br><br>SetAlgebraType申明了集合运算操作函数, OptionSetType是用来在swift中实现OC中类似枚举多选的功能的类型<br><br>两个StringConvertible协议的description返回的string是用在print/debugPrint中作为对象的打印值<br></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/30/Swift-Standard-Library-1/" data-id="cir8ktab60001yrs6qkyxmmr8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Swift-Standard-Library-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/30/Swift-Standard-Library-2/" class="article-date">
  <time datetime="2016-01-30T12:02:57.000Z" itemprop="datePublished">2016-01-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/swift/">swift</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/30/Swift-Standard-Library-2/">Swift Standard Library 2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Swift-Standard-Library-2"><a href="#Swift-Standard-Library-2" class="headerlink" title="Swift Standard Library 2"></a>Swift Standard Library 2</h1><p><strong>标准库中的类型和函数</strong><br>在上一篇中, 我们将标准库中的协议做了分类学习, 在本篇, 我们来分类学习下标准库中的类型(包含struct, class, enum)和函数(包括操作符)</p>
<h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><h3 id="1-Basic"><a href="#1-Basic" class="headerlink" title="1.Basic"></a>1.Basic</h3><ul>
<li>Bit</li>
<li>Bool</li>
<li>Character</li>
<li>Float/Float80</li>
<li>Double</li>
<li>Int/Int8/Int16/Int32/Int64</li>
<li>UInt/UInt8/UInt16/UInt32/UInt64</li>
</ul>
<p>以上基本类型跟其他语言中对应基本类型类似, 相对比较简单, 这里就不做过多说明了</p>
<h3 id="2-Optional"><a href="#2-Optional" class="headerlink" title="2.Optional"></a>2.Optional</h3><ul>
<li>Optional</li>
<li>ImplicitlyUnwrappedOptional</li>
</ul>
<p>swift中的Optional也许是最重要的类型, 也是很多其他语言中没有的类型, 来看下它是怎么定义的吧</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">Wrapped</span>&gt; : <span class="title">_Reflectable</span>, <span class="title">NilLiteralConvertible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">None</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Some</span>(<span class="type">Wrapped</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">T</span> = <span class="type">Wrapped</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>() &#123; <span class="keyword">self</span> = .<span class="type">None</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> some: <span class="type">Wrapped</span>) &#123; <span class="keyword">self</span> = .<span class="type">Some</span>(some) &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If `self == nil`, returns `nil`.  Otherwise, returns `f(self!)`.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(@noescape f: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>? &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Some</span>(<span class="keyword">let</span> y):</span><br><span class="line">      <span class="keyword">return</span> .<span class="type">Some</span>(<span class="keyword">try</span> f(y))</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">None</span>:</span><br><span class="line">      <span class="keyword">return</span> .<span class="type">None</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns `nil` if `self` is `nil`, `f(self!)` otherwise.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(@noescape f: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U</span>?) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>? &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Some</span>(<span class="keyword">let</span> y):</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">try</span> f(y)</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">None</span>:</span><br><span class="line">      <span class="keyword">return</span> .<span class="type">None</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(nilLiteral: ()) &#123;</span><br><span class="line">    <span class="keyword">self</span> = .<span class="type">None</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>标准库中还通过extension的方式让Optional实现了 <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>以及特有的<code>??</code>操作</p>
</blockquote>
<p>通过源码可以看到Optional是一个带有泛型参数的enum类型, 他有两种情况(case), 一种是None, 代表没有值, 一种是Some(Wrapped), 代表有值; 可以把Optional比喻为一个盒子, 盒子可以是空的, 即None; 也可以把一个值放到盒子里面, 即是Some(Wrapped). swift中提供了语法糖放我们很方便来使用Optional, 比如下面的代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">optional</span>: <span class="type">Int</span>? = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>其实是下面代码的简写<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">optional</span>: <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt; = <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt;.<span class="type">Some</span>(<span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>
<p>所以不要小看Int后面那个”?”, 要注意的是上面的optional不再是一个Int类型了, 而是一个<strong>Optional</strong> <br><br>既然可以把一个值放到optional里面, 那怎么把放进去的值读出来, 或者是引用到里面的值呢? 下面总结了9种办法, 适用于不同的场景</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. if let</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> unwrapped = <span class="keyword">optional</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(unwrapped)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. forced unwrapping</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">optional</span>!)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.guard let</span></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">var</span> globalUnwrapped = <span class="keyword">optional</span> <span class="keyword">else</span> &#123; <span class="built_in">preconditionFailure</span>()&#125;</span><br><span class="line"><span class="built_in">print</span>(globalUnwrapped)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. pattern matching</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> unwrapped? = <span class="keyword">optional</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(unwrapped)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. unsafeUnwrap</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">unsafeUnwrap</span>(<span class="keyword">optional</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. map</span></span><br><span class="line"><span class="keyword">optional</span>.<span class="built_in">map</span>&#123;<span class="built_in">print</span>($<span class="number">0</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7. implicity unwrapped optional case</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">optional</span> <span class="keyword">as</span> <span class="type">Int</span>!)</span><br><span class="line"></span><br><span class="line"><span class="comment">//8. optional chaining</span></span><br><span class="line"><span class="keyword">optional</span>?.description</span><br><span class="line"></span><br><span class="line"><span class="comment">//9. nil coalescing</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">optional</span> ?? <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>ImplicitlyUnwrappedOptional跟Optional比较类似, 这里就不讨论了</p>
<h3 id="3-Common-Used"><a href="#3-Common-Used" class="headerlink" title="3.Common Used"></a>3.Common Used</h3><ul>
<li>String/StaticString</li>
<li>Array/ArraySlice/ContiguousArray</li>
<li>Slice/MutableSlice</li>
<li>ClosedInterval/HalfOpenInterval</li>
</ul>
<p>上面几种类型是平常经常使用的, Slice类型可以认为是某个集合类型上的一段子集, Interval类型是区间类型<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment">//slice的类型是ArraySlice&lt;Int&gt;</span></span><br><span class="line"><span class="keyword">var</span> slice = array[<span class="number">2</span>...<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//interval的类型是HalfOpenInterval&lt;Double&gt;</span></span><br><span class="line"><span class="keyword">var</span> interval = <span class="number">1.0</span>..&lt;<span class="number">10.0</span></span><br></pre></td></tr></table></figure></p>
<h3 id="4-Sequence-Collection"><a href="#4-Sequence-Collection" class="headerlink" title="4.Sequence/Collection"></a>4.Sequence/Collection</h3><p>标注库中提供了多样的Sequence和Collection类型, 所以这里我们还可以细分一下.<br><br>首先来回顾下上一篇讲到的Generator, Sequence, Collection和Index的概念</p>
<ul>
<li>Generator: 封装了迭代一个Sequence的接口, 即可以通过它来迭代访问Sequence中的元素</li>
<li>Sequence: 序列类型, 有一个generate方法, 这个方法返回就是对应的GeneratorType对象</li>
<li>Collection: 集合类型, 继承Sequence, 其元素还可以通过Index来索引</li>
<li>Index: 用于索引Collection中的元素</li>
</ul>
<p>可以把他们之间的关系总结如下</p>
<ul>
<li>每个Sequence类型都对应一种Generator类型</li>
<li>每个Collection类型都对应一种Index类型</li>
<li>每个Collection类型都是Sequence类型, 所以也有对应的Generator类型</li>
</ul>
<p>那就开始学习吧</p>
<h4 id="4a-old-friends"><a href="#4a-old-friends" class="headerlink" title="4a. old friends"></a>4a. old friends</h4><table>
<thead>
<tr>
<th style="text-align:center">Generator</th>
<th style="text-align:center">Sequence</th>
<th style="text-align:center">Collection</th>
<th style="text-align:center">Index</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center"></td>
<td style="text-align:center">Array</td>
<td style="text-align:center">Int</td>
</tr>
<tr>
<td style="text-align:center">DictionaryGenerator</td>
<td style="text-align:center"></td>
<td style="text-align:center">Dictionary</td>
<td style="text-align:center">DictionaryIndex</td>
</tr>
<tr>
<td style="text-align:center">SetGenerator</td>
<td style="text-align:center"></td>
<td style="text-align:center">Set</td>
<td style="text-align:center">SetIndex</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Array的Generator类型是<code>IndexingGenerator&lt;Array&lt;Element&gt;&gt;</code></p>
</blockquote>
<p>以上是我们的老朋友啦, 没想到的是他们也有对应的Generator类型吧</p>
<h4 id="4b-new-friends"><a href="#4b-new-friends" class="headerlink" title="4b. new friends"></a>4b. new friends</h4><table>
<thead>
<tr>
<th style="text-align:center">Generator</th>
<th style="text-align:center">Sequence</th>
<th style="text-align:center">Collection</th>
<th style="text-align:center">Index</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">EmptyGenerator</td>
<td style="text-align:center"></td>
<td style="text-align:center">EmptyCollection</td>
<td style="text-align:center">Int</td>
</tr>
<tr>
<td style="text-align:center">GeneratorOfOne</td>
<td style="text-align:center"></td>
<td style="text-align:center">CollectionOfOne</td>
<td style="text-align:center">Bit</td>
</tr>
<tr>
<td style="text-align:center">RangeGenerator</td>
<td style="text-align:center"></td>
<td style="text-align:center">Range</td>
<td style="text-align:center">Element</td>
</tr>
<tr>
<td style="text-align:center">IndexingGenerator<repeat<element>&gt;</repeat<element></td>
<td style="text-align:center"></td>
<td style="text-align:center">Repeat</td>
<td style="text-align:center">Int</td>
</tr>
</tbody>
</table>
<ul>
<li>EmptyCollection比较有意思, 它是一个空的集合, 既不能往里放元素也不能取, 不然都会出现运行时错误</li>
<li>CollectionOfOne, 只能放一个元素的集合</li>
<li>Range, 区间集合,比如<code>[1...4]</code>就是一个Range</li>
<li>Repeat, 重复一个元素的集合</li>
</ul>
<h4 id="4c-Any"><a href="#4c-Any" class="headerlink" title="4c. Any"></a>4c. Any</h4><table>
<thead>
<tr>
<th style="text-align:center">Generator</th>
<th style="text-align:center">Sequence</th>
<th style="text-align:center">Collection</th>
<th style="text-align:center">Index</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AnyGenerator</td>
<td style="text-align:center">AnySequence</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">AnyGenerator</td>
<td style="text-align:center"></td>
<td style="text-align:center">AnyForwordCollection</td>
<td style="text-align:center">AnyForwordIndex</td>
</tr>
<tr>
<td style="text-align:center">AnyGenerator</td>
<td style="text-align:center"></td>
<td style="text-align:center">AnyBidirectionalCollection</td>
<td style="text-align:center">AnyBidirectionalIndex</td>
</tr>
<tr>
<td style="text-align:center">AnyGenerator</td>
<td style="text-align:center"></td>
<td style="text-align:center">AnyRandomAccessCollection</td>
<td style="text-align:center">AnyRandomAccessIndex</td>
</tr>
</tbody>
</table>
<p>这类的集合类型是type-erase集合类型, 可以在某些情况下简化类型信息</p>
<h4 id="4d-Flatten"><a href="#4d-Flatten" class="headerlink" title="4d. Flatten"></a>4d. Flatten</h4><table>
<thead>
<tr>
<th style="text-align:center">Generator</th>
<th style="text-align:center">Sequence</th>
<th style="text-align:center">Collection</th>
<th style="text-align:center">Index</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FlattenGenerator</td>
<td style="text-align:center">FlattenSequence</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">FlattenGenerator</td>
<td style="text-align:center"></td>
<td style="text-align:center">FlattenCollection</td>
<td style="text-align:center">FlattenCollectionIndex</td>
</tr>
<tr>
<td style="text-align:center">FlattenGenerator</td>
<td style="text-align:center"></td>
<td style="text-align:center">FlattenBidirectionalCollection</td>
<td style="text-align:center">FlattenBidirectionalCollectionIndex</td>
</tr>
</tbody>
</table>
<p>每个CollectionType都有flatten函数, 它返回的就是一个FlattenCollection, 举个例子吧</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment">//array是个二维数组(元素是数组的数组)</span></span><br><span class="line"><span class="keyword">var</span> array = [array1, array2];</span><br><span class="line"><span class="comment">//flatten的类型是FlattenBidirectionalCollection&lt;[[Int]]&gt; 等价于将array里面的数组元素连接到一起了</span></span><br><span class="line"><span class="keyword">let</span> flatten = array.flatten()</span><br><span class="line"><span class="comment">//打印结果 [1 2 3 4 5 6 7]</span></span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> flatten &#123;</span><br><span class="line">    <span class="built_in">print</span>(ele)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4e-Lazy"><a href="#4e-Lazy" class="headerlink" title="4e. Lazy"></a>4e. Lazy</h4><table>
<thead>
<tr>
<th style="text-align:center">Generator</th>
<th style="text-align:center">Sequence</th>
<th style="text-align:center">Collection</th>
<th style="text-align:center">Index</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LazyGenerator</td>
<td style="text-align:center">LazySequence</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">LazyFilterGenerator</td>
<td style="text-align:center">LazyFilterSequence</td>
<td style="text-align:center">LazyFilterCollection</td>
<td style="text-align:center">LazyFilterIndex</td>
</tr>
<tr>
<td style="text-align:center">LazyMapGenerator</td>
<td style="text-align:center">LazyMapSequence</td>
<td style="text-align:center">LazyMapCollection</td>
<td style="text-align:center">Base.Index</td>
</tr>
</tbody>
</table>
<p>Lazy集合的元素是只有被第一次访问的时候才被求值</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">//seq的类型是[Int]</span></span><br><span class="line"><span class="keyword">let</span> seq = items.<span class="built_in">map</span>&#123;</span><br><span class="line">    (i: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"mapping \(i)"</span>)</span><br><span class="line">        <span class="keyword">return</span> i * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行到这里会打印出5行mapping</span></span><br><span class="line"><span class="comment">//mapping 1</span></span><br><span class="line"><span class="comment">//mapping 2</span></span><br><span class="line"><span class="comment">//mapping 3</span></span><br><span class="line"><span class="comment">//mapping 4</span></span><br><span class="line"><span class="comment">//mapping 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//lazySeq的类型是LazyMapCollection&lt;[Int], Int&gt;</span></span><br><span class="line"><span class="keyword">let</span> lazySeq = items.<span class="built_in">lazy</span>.<span class="built_in">map</span>&#123;</span><br><span class="line">    (i: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"mapping \(i)"</span>)</span><br><span class="line">        <span class="keyword">return</span> i * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行到这里不会有新的打印值</span></span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> lazySeq &#123;</span><br><span class="line">    <span class="built_in">print</span>(ele)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//到这里时结果是</span></span><br><span class="line"><span class="comment">//mapping 1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//mapping 2</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//mapping 3</span></span><br><span class="line"><span class="comment">//6</span></span><br><span class="line"><span class="comment">//mapping 4</span></span><br><span class="line"><span class="comment">//8</span></span><br><span class="line"><span class="comment">//mapping 5</span></span><br><span class="line"><span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p>可以看出Lazy的collection的元素是惰性求值的</p>
<h4 id="4f-Reverse"><a href="#4f-Reverse" class="headerlink" title="4f. Reverse"></a>4f. Reverse</h4><table>
<thead>
<tr>
<th style="text-align:center">Generator</th>
<th style="text-align:center">Sequence</th>
<th style="text-align:center">Collection</th>
<th style="text-align:center">Index</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IndexingGenerator<reversecollection<base>&gt;</reversecollection<base></td>
<td style="text-align:center"></td>
<td style="text-align:center">ReverseCollection</td>
<td style="text-align:center">ReverseIndex</td>
</tr>
<tr>
<td style="text-align:center">IndexingGenerator<reverserandomaccesscollection<base>&gt;</reverserandomaccesscollection<base></td>
<td style="text-align:center"></td>
<td style="text-align:center">ReverseRandomAccessCollection</td>
<td style="text-align:center">ReverseRandomAccessIndex</td>
</tr>
</tbody>
</table>
<p>每个CollectionType类型都有一个reverse函数, 猜也知道它是干什么用的. 但是请大家想一下在一个数字上调用reverse函数, 会返回一个什么类型呢? 按理说数组逆序还是数组啊, 然而并不是</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">//reverse的类型是ReverseRandomAccessCollection&lt;[Int]&gt;</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">reverse</span> = items.<span class="built_in">reverse</span>()</span><br></pre></td></tr></table></figure>
<p>没想到吧, 这体验出swift类型系统的强大, 类型信息的准确. 最开始接触的时候可能会不习惯, 但是最终你会爱上它的:)</p>
<h4 id="4g-others"><a href="#4g-others" class="headerlink" title="4g. others"></a>4g. others</h4><table>
<thead>
<tr>
<th style="text-align:center">Generator</th>
<th style="text-align:center">Sequence</th>
<th style="text-align:center">Collection</th>
<th style="text-align:center">Index</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">EnumerateGenerator</td>
<td style="text-align:center">EnumerateSequence</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">JoinGenerator</td>
<td style="text-align:center">JoinSequence</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">StrideThroughGenerator</td>
<td style="text-align:center">StrideThrough</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">StrideToGenerator</td>
<td style="text-align:center">StrideTo</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Zip2Generator</td>
<td style="text-align:center">Zip2Sequence</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>这些我就不再一一举例了, 去官方文档有详细的说明</p>
<h2 id="Typealias"><a href="#Typealias" class="headerlink" title="Typealias"></a>Typealias</h2><p>刚才花了大量的篇幅来介绍标准库的类型, 是不是感觉有点喘不过来气了, 好消息是我们已经啃完了最难的部分, 剩下的内容很少了, 都是下坡路哈<br><br></p>
<p>标准库中还定义了很多Typealias来作为别名使用, 多数是为了简写, 这里我只提及一个<code>Void</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// The empty tuple type.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This is the default return type of functions for which no explicit</span></span><br><span class="line"><span class="comment">/// return type is specified.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Void</span> = ()</span><br></pre></td></tr></table></figure>
<p>这个Void可跟我们之前在OC里面认识的那个完全不一样, 它其实就是空元组</p>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p>标准库中定义的全局函数比较少, 只有30+, 像之前提到的swap, 大多简单易用, 下面是我们常用的几个</p>
<ul>
<li>print</li>
<li>fatalError</li>
<li>assert/assertionFailure</li>
<li>precondition/preconditionFailure</li>
<li>swap</li>
<li>min/max</li>
</ul>
<p>其他的大家看文档就好</p>
<h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h2><p>swift中的Operator都是函数的一种, 并且都是全局的, 下面是swift中引入的几个新的operator</p>
<ul>
<li>===/!==</li>
<li>…/..&lt;</li>
<li>??</li>
<li>~=</li>
</ul>
<p>前3个就不讲了, 要是不知道的话说明语法还没有掌握哦, 最后一个有点意思, 可以通过重载它来实现自定义的模式匹配.<br></p>
<p>除了可以重载外, swift还允许我们自定义新的操作符, 简直是语言玩家的福音.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/30/Swift-Standard-Library-2/" data-id="cir8ktabb0003yrs65g437eef" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Swift-OptionSetType" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/26/Swift-OptionSetType/" class="article-date">
  <time datetime="2015-12-26T12:02:57.000Z" itemprop="datePublished">2015-12-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/swift/">swift</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/26/Swift-OptionSetType/">Swift学习笔记－－OptionSetType</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="实现自定义多选类型"><a href="#实现自定义多选类型" class="headerlink" title="实现自定义多选类型"></a>实现自定义多选类型</h1><h2 id="Objective-C中的枚举多选"><a href="#Objective-C中的枚举多选" class="headerlink" title="Objective-C中的枚举多选"></a>Objective-C中的枚举多选</h2><p>UIView的一个常用属性是autoresizingMask是一个枚举类型，在设置其值时通常被设置为多个值的组合，例如</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">UIViewAutoresizing</span>) &#123;</span><br><span class="line">    <span class="built_in">UIViewAutoresizingNone</span>                 = <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span>   = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleWidth</span>        = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleRightMargin</span>  = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleTopMargin</span>    = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleHeight</span>       = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleBottomMargin</span> = <span class="number">1</span> &lt;&lt; <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line">view.autoresizingMask = <span class="built_in">UIViewAutoresizingFlexibleWidth</span> | <span class="built_in">UIViewAutoresizingFlexibleHeight</span>;</span><br></pre></td></tr></table></figure>
<p>OC中的枚举值其实就是整数值，所以可以通过按位与操作来实现多选</p>
<h2 id="Swift中的多选"><a href="#Swift中的多选" class="headerlink" title="Swift中的多选"></a>Swift中的多选</h2><p>那在swift中该怎么做呢，swift中的enum不再是整数类型，所以是不能再使用按位与操作，看下swift中autoresizingMask是怎么定义和使用的<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">UIViewAutoresizing</span> : <span class="title">OptionSetType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(rawValue: <span class="type">UInt</span>)   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">None</span>: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">FlexibleLeftMargin</span>: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">FlexibleWidth</span>: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">FlexibleRightMargin</span>: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">FlexibleTopMargin</span>: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">FlexibleHeight</span>: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">FlexibleBottomMargin</span>: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">view.autoresizingMask = [.<span class="type">FlexibleHeight</span>, .<span class="type">FlexibleHeight</span>]</span><br></pre></td></tr></table></figure></p>
<p>swift中的UIViewAutoresizing不再是enum类型，而是一个遵从了OptionSetType协议的struct，然后所有的可能值被定义为public的readonly的static变量，并且这些可能的值的类型都是UIViewAutoresizing，在使用多个值的时候，把多个可能值放到一个数组中，然后赋值就可以了</p>
<h2 id="在swift中实现自定义的多选类型"><a href="#在swift中实现自定义的多选类型" class="headerlink" title="在swift中实现自定义的多选类型"></a>在swift中实现自定义的多选类型</h2><p>上面我们看到了UIViewAutoresizing在Swift中是怎么实现的,那是不是能照着样子来实现一个自定义的多选类型呢,就像这样<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Direction</span> : <span class="title">OptionSetType</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(rawValue: <span class="type">UInt</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">East</span>  : <span class="type">Direction</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">South</span> : <span class="type">Direction</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">West</span>  : <span class="type">Direction</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">Nouth</span> : <span class="type">Direction</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而不行,像上面的代码会被编译器无情的拒绝<br><img src="https://cloud.githubusercontent.com/assets/1595401/12009254/9de711b6-acab-11e5-81bf-bae4d8ff132d.png" alt="image"></p>
<p>完整的写法应该是这样的<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Direction</span> : <span class="title">OptionSetType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> rawValue : <span class="type">UInt</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(rawValue: <span class="type">UInt</span>) &#123; <span class="keyword">self</span>.rawValue = rawValue &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">East</span>  : <span class="type">Direction</span> &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="type">Direction</span>(rawValue : <span class="number">0</span>) &#125; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">South</span> : <span class="type">Direction</span> &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="type">Direction</span>(rawValue : <span class="number">1</span>) &#125; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">West</span>  : <span class="type">Direction</span> &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="type">Direction</span>(rawValue : <span class="number">1</span> &lt;&lt; <span class="number">1</span>) &#125; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">Nouth</span> : <span class="type">Direction</span> &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="type">Direction</span>(rawValue : <span class="number">1</span> &lt;&lt; <span class="number">2</span>) &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样虽然编译器不抱怨了,但太繁琐,下面是更简洁的写法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Direction</span> : <span class="title">OptionSetType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> rawValue : <span class="type">UInt</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(rawValue: <span class="type">UInt</span>) &#123; <span class="keyword">self</span>.rawValue = rawValue&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">East</span>  = <span class="type">Direction</span>(rawValue : <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">South</span> = <span class="type">Direction</span>(rawValue : <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">West</span>  = <span class="type">Direction</span>(rawValue : <span class="number">1</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Nouth</span> = <span class="type">Direction</span>(rawValue : <span class="number">1</span> &lt;&lt; <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果这个多选类型不会被外部的模块使用,还可以再简写一下<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Direction</span> : <span class="title">OptionSetType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> rawValue : <span class="type">UInt</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">East</span>  = <span class="type">Direction</span>(rawValue : <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">South</span> = <span class="type">Direction</span>(rawValue : <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">West</span>  = <span class="type">Direction</span>(rawValue : <span class="number">1</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Nouth</span> = <span class="type">Direction</span>(rawValue : <span class="number">1</span> &lt;&lt; <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在使用方式和UIViewAutoresizing是一致的</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> direction : <span class="type">Direction</span> = [.<span class="type">East</span>, .<span class="type">South</span>]</span><br></pre></td></tr></table></figure>
<h2 id="Swift多选类型支持的操作"><a href="#Swift多选类型支持的操作" class="headerlink" title="Swift多选类型支持的操作"></a>Swift多选类型支持的操作</h2><p>在Objective-c中可以通过位运算来检查一个多选项是否被包含在一个枚举变量中,还可以向一个枚举变量增加一个选项,在swift对应的操作是什么呢? 这时就要到OptionSetType这个协议来找答案了,先看下这个协议是怎么定义的</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Supplies convenient conformance to `SetAlgebraType` for any type</span></span><br><span class="line"><span class="comment">/// whose `RawValue` is a `BitwiseOperationsType`.  For example:</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     struct PackagingOptions : OptionSetType &#123;</span></span><br><span class="line"><span class="comment">///       let rawValue: Int</span></span><br><span class="line"><span class="comment">///       init(rawValue: Int) &#123; self.rawValue = rawValue &#125;</span></span><br><span class="line"><span class="comment">///     </span></span><br><span class="line"><span class="comment">///       static let Box = PackagingOptions(rawValue: 1)</span></span><br><span class="line"><span class="comment">///       static let Carton = PackagingOptions(rawValue: 2)</span></span><br><span class="line"><span class="comment">///       static let Bag = PackagingOptions(rawValue: 4)</span></span><br><span class="line"><span class="comment">///       static let Satchel = PackagingOptions(rawValue: 8)</span></span><br><span class="line"><span class="comment">///       static let BoxOrBag: PackagingOptions = [Box, Bag]</span></span><br><span class="line"><span class="comment">///       static let BoxOrCartonOrBag: PackagingOptions = [Box, Carton, Bag]</span></span><br><span class="line"><span class="comment">///     &#125;</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// In the example above, `PackagingOptions.Element` is the same type</span></span><br><span class="line"><span class="comment">/// as `PackagingOptions`, and instance `a` subsumes instance `b` if</span></span><br><span class="line"><span class="comment">/// and only if `a.rawValue &amp; b.rawValue == b.rawValue`.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">OptionSetType</span> : <span class="title">SetAlgebraType</span>, <span class="title">RawRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// An `OptionSet`'s `Element` type is normally `Self`.</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> = <span class="type">Self</span></span><br><span class="line">    <span class="comment">/// Convert from a value of `RawValue`, succeeding unconditionally.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(rawValue: <span class="type">Self</span>.<span class="type">RawValue</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是OptionSetType协议在标准库里面的定义, 这里我们只看到这个协议继承了两个协议SetAlgebraType和RawRepresentable, RawRepresentable比较简单</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A type that can be converted to an associated "raw" type, then</span></span><br><span class="line"><span class="comment">/// converted back to produce an instance equivalent to the original.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">RawRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// The "raw" type that can be used to represent all values of `Self`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// Every distinct value of `self` has a corresponding unique</span></span><br><span class="line">    <span class="comment">/// value of `RawValue`, but `RawValue` may have representations</span></span><br><span class="line">    <span class="comment">/// that do not correspond to an value of `Self`.</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">RawValue</span></span><br><span class="line">    <span class="comment">/// Convert from a value of `RawValue`, yielding `nil` iff</span></span><br><span class="line">    <span class="comment">/// `rawValue` does not correspond to a value of `Self`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>?(rawValue: <span class="type">Self</span>.<span class="type">RawValue</span>)</span><br><span class="line">    <span class="comment">/// The corresponding value of the "raw" type.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// `Self(rawValue: self.rawValue)!` is equivalent to `self`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> rawValue: <span class="type">Self</span>.<span class="type">RawValue</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而更重要的是SetAlgebraType</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A generalized set whose distinct elements are not necessarily</span></span><br><span class="line"><span class="comment">/// disjoint.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// In a model of `SetAlgebraType`, some elements may subsume other</span></span><br><span class="line"><span class="comment">/// elements, where</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// &gt; `a` **subsumes** `b` iff `([a] as Self).isSupersetOf([b])`</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// In many models of `SetAlgebraType` such as `Set&lt;T&gt;`, `a`</span></span><br><span class="line"><span class="comment">/// *subsumes* `b` if and only if `a == b`, but that is not always the</span></span><br><span class="line"><span class="comment">/// case.  For example, option sets typically do not satisfy that</span></span><br><span class="line"><span class="comment">/// property.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Two elements are **disjoint** when neither one *subsumes* the other.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - SeeAlso: `OptionSetType`.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Axioms, where `S` conforms to `SetAlgebraType`, `x` and `y` are</span></span><br><span class="line"><span class="comment">///   of type `S`, and `e` is of type `S.Element`:</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///   - `S() == []`</span></span><br><span class="line"><span class="comment">///   - `x.intersect(x) == x`</span></span><br><span class="line"><span class="comment">///   - `x.intersect([]) == []`</span></span><br><span class="line"><span class="comment">///   - `x.union(x) == x`</span></span><br><span class="line"><span class="comment">///   - `x.union([]) == x`</span></span><br><span class="line"><span class="comment">///   - `x.contains(e)` implies `x.union(y).contains(e)`</span></span><br><span class="line"><span class="comment">///   - `x.union(y).contains(e)` implies `x.contains(e) || y.contains(e)`</span></span><br><span class="line"><span class="comment">///   - `x.contains(e) &amp;&amp; y.contains(e)` iff `x.intersect(y).contains(e)`</span></span><br><span class="line"><span class="comment">///   - `x.isSubsetOf(y)` iff `y.isSupersetOf(x)`</span></span><br><span class="line"><span class="comment">///   - `x.isStrictSupersetOf(y)` iff `x.isSupersetOf(y) &amp;&amp; x != y`</span></span><br><span class="line"><span class="comment">///   - `x.isStrictSubsetOf(y)` iff `x.isSubsetOf(y) &amp;&amp; x != y`</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">SetAlgebraType</span> : <span class="title">Equatable</span>, <span class="title">ArrayLiteralConvertible</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// A type for which `Self` provides a containment test.</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span></span><br><span class="line">    <span class="comment">/// Creates an empty set.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Equivalent to `[] as Self`</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>()</span><br><span class="line">    <span class="comment">/// Returns `true` if `self` contains `member`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Equivalent to `self.intersect([member]) == [member]`</span></span><br><span class="line">    <span class="meta">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(member: <span class="keyword">Self</span>.Element)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// Returns the set of elements contained in `self`, in `other`, or in</span></span><br><span class="line">    <span class="comment">/// both `self` and `other`.</span></span><br><span class="line">    <span class="meta">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">union</span><span class="params">(other: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Self</span></span><br><span class="line">    <span class="comment">/// Returns the set of elements contained in both `self` and `other`.</span></span><br><span class="line">    <span class="meta">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">intersect</span><span class="params">(other: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Self</span></span><br><span class="line">    <span class="comment">/// Returns the set of elements contained in `self` or in `other`,</span></span><br><span class="line">    <span class="comment">/// but not in both `self` and `other`.</span></span><br><span class="line">    <span class="meta">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">exclusiveOr</span><span class="params">(other: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Self</span></span><br><span class="line">    <span class="comment">/// If `member` is not already contained in `self`, inserts it.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Equivalent to `self.unionInPlace([member])`</span></span><br><span class="line">    <span class="comment">/// - Postcondition: `self.contains(member)`</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(member: <span class="keyword">Self</span>.Element)</span></span></span><br><span class="line">    <span class="comment">/// If `member` is contained in `self`, removes and returns it.</span></span><br><span class="line">    <span class="comment">/// Otherwise, removes all elements subsumed by `member` and returns</span></span><br><span class="line">    <span class="comment">/// `nil`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Postcondition: `self.intersect([member]).isEmpty`</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(member: <span class="keyword">Self</span>.Element)</span></span> -&gt; <span class="type">Self</span>.<span class="type">Element</span>?</span><br><span class="line">    <span class="comment">/// Insert all elements of `other` into `self`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Equivalent to replacing `self` with `self.union(other)`.</span></span><br><span class="line">    <span class="comment">/// - Postcondition: `self.isSupersetOf(other)`</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">unionInPlace</span><span class="params">(other: <span class="keyword">Self</span>)</span></span></span><br><span class="line">    <span class="comment">/// Removes all elements of `self` that are not also present in</span></span><br><span class="line">    <span class="comment">/// `other`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Equivalent to replacing `self` with `self.intersect(other)`</span></span><br><span class="line">    <span class="comment">/// - Postcondition: `self.isSubsetOf(other)`</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">intersectInPlace</span><span class="params">(other: <span class="keyword">Self</span>)</span></span></span><br><span class="line">    <span class="comment">/// Replaces `self` with a set containing all elements contained in</span></span><br><span class="line">    <span class="comment">/// either `self` or `other`, but not both.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Equivalent to replacing `self` with `self.exclusiveOr(other)`</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">exclusiveOrInPlace</span><span class="params">(other: <span class="keyword">Self</span>)</span></span></span><br><span class="line">    <span class="comment">/// Return true iff `self.intersect(other).isEmpty`.</span></span><br><span class="line">    <span class="meta">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">subtract</span><span class="params">(other: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Self</span></span><br><span class="line">    <span class="comment">/// Return true iff every element of `self` is contained in `other`.</span></span><br><span class="line">    <span class="meta">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">isSubsetOf</span><span class="params">(other: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// Return true iff `self.intersect(other).isEmpty`.</span></span><br><span class="line">    <span class="meta">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">isDisjointWith</span><span class="params">(other: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// Return true iff every element of `other` is contained in `self`.</span></span><br><span class="line">    <span class="meta">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">isSupersetOf</span><span class="params">(other: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// Return true iff `self.contains(e)` is `false` for all `e`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">/// Creates the set containing all elements of `sequence`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">S</span> : <span class="type">SequenceType</span> <span class="keyword">where</span> <span class="type">S</span>.<span class="type">Generator</span>.<span class="type">Element</span> == <span class="type">Element</span>&gt;(<span class="number">_</span> sequence: <span class="type">S</span>)</span><br><span class="line">    <span class="comment">/// Removes all elements of `other` from `self`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Equivalent to replacing `self` with `self.subtract(other)`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">subtractInPlace</span><span class="params">(other: <span class="keyword">Self</span>)</span></span></span><br><span class="line">    <span class="comment">/// Returns `true` iff `a` subsumes `b`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Equivalent to `([a] as Self).isSupersetOf([b])`</span></span><br><span class="line">    <span class="meta">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">element</span><span class="params">(a: <span class="keyword">Self</span>.Element, subsumes b: <span class="keyword">Self</span>.Element)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// Returns `true` iff `a` is disjoint with `b`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// Two elements are disjoint when neither one subsumes the other.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - SeeAlso: `Self.element(_, subsumes:_)`</span></span><br><span class="line">    <span class="meta">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">element</span><span class="params">(a: <span class="keyword">Self</span>.Element, isDisjointWith b: <span class="keyword">Self</span>.Element)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SetAlgebraType就像其名字一样,声明了众多集合代数类型的操作,在标准库中,大部分这些方法都以extension的方式提供了默认的实现,所以可以供我们直接使用,以之前定义的Direction为例,</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> direction1 : <span class="type">Direction</span> = [.<span class="type">East</span>, .<span class="type">South</span>]</span><br><span class="line"><span class="keyword">var</span> direction2 : <span class="type">Direction</span> = [.<span class="type">East</span>, .<span class="type">North</span>]</span><br></pre></td></tr></table></figure>
<p><strong>添加一个选项</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">direction1.insert(.<span class="type">West</span>)</span><br></pre></td></tr></table></figure>
<p><strong>检查一个选项是否被包含</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> containEast : <span class="type">Bool</span> = direction1.<span class="built_in">contains</span>(.<span class="type">East</span>)</span><br></pre></td></tr></table></figure>
<p><strong>两个多选类型值的交集</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directoin = direction1.intersect(direction2)</span><br></pre></td></tr></table></figure>
<p>还有其他的操作这里就不再列举了</p>
<p>这里还提一点就是SetAlgebraType继承自ArrayLiteralConvertible, 从名字我们就能看出来为什么自定义的多选类型变量可以通过数值字面量赋值了, 具体细节请参考标准库里面的说明吧</p>
<h2 id="写在最后-Why"><a href="#写在最后-Why" class="headerlink" title="写在最后:Why?"></a>写在最后:Why?</h2><p>那为什么在swift中要把之前我们用的好好的枚举实现成这样的?我个人认为最重要的就是两个字:<strong>类型</strong><br>在OC中,枚举其实就是整数类型, 枚举选项就是整型常量, 枚举变量就是一个整型的变量,所以可以把一个整数赋值给一个枚举变量, 也可以把枚举变量当做整型变量来使用,所以可以说OC中是不存在真正的多选类型.虽然这样有了灵活性,但丧失了类型信息,也就没了安全性.比如我们可以把一个不是任何有效选项的整数值赋值给一个枚举变量,而编译器并不会抱怨.</p>
<p>Swift是一门很强调安全性的语言,而强类型就是方式之一.这种强类型系统已经不允许我们把0当做Bool类型中的false来使用了,比如下面的代码就会被编译器无情的拒绝</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b : <span class="type">Bool</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>在Swift中的多选类型不再等同于整型,严格的说是不再等同任何其他类型,这样看起来是丧失了灵活性,但是带来的好处是我们不能也不允许把一个无效的值赋给多选类型变量了,因为编译器能够很好的检查出来这样错误,避免把隐患带到执行期,来提高程序的安全性.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/26/Swift-OptionSetType/" data-id="cir8ktab20000yrs6ocew0e9r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorier</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/swift/">swift</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Arkiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Siste innlegg</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/09/11/iOS-view-布局详解3/">iOS view 布局详解3</a>
          </li>
        
          <li>
            <a href="/2016/08/18/iOS-view-布局详解2/">iOS view 布局详解2</a>
          </li>
        
          <li>
            <a href="/2016/07/26/iOS-view-布局详解1/">iOS view 布局详解1</a>
          </li>
        
          <li>
            <a href="/2016/06/10/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2016/01/30/Swift-Standard-Library-1/">Swift Standard Library 1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>